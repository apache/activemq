/*
* Licensed to the Apache Software Foundation (ASF) under one or more
* contributor license agreements.  See the NOTICE file distributed with
* this work for additional information regarding copyright ownership.
* The ASF licenses this file to You under the Apache License, Version 2.0
* (the "License"); you may not use this file except in compliance with
* the License.  You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
#include "activemq/command/WireFormatInfo.hpp"

using namespace apache::activemq::command;

/*
 *
 *  Marshalling code for Open Wire Format for WireFormatInfo
 *
 *
 *  NOTE!: This file is autogenerated - do not modify!
 *         if you need to make a change, please see the Groovy scripts in the
 *         activemq-core module
 *
 */
WireFormatInfo::WireFormatInfo()
{    
    this->magic         = array<char> (8) ;
    this->version       = 0 ;
    this->propsByteSize = 0 ;
    this->properties    = new PropertyMap() ;
}

unsigned char WireFormatInfo::getDataStructureType()
{
    return WireFormatInfo::TYPE ; 
}

        
array<char> WireFormatInfo::getMagic()
{
    return magic ;
}

void WireFormatInfo::setMagic(array<char> magic)
{
    this->magic = magic ;
}

        
int WireFormatInfo::getVersion()
{
    return version ;
}

void WireFormatInfo::setVersion(int version)
{
    this->version = version ;
}

        
bool WireFormatInfo::getCacheEnabled()
{
    return (*properties)["CacheEnabled"].getBoolean() ;
}

void WireFormatInfo::setCacheEnabled(bool cacheEnabled)
{
    (*properties)["CacheEnabled"] = MapItemHolder(cacheEnabled) ;
}

        
bool WireFormatInfo::getStackTraceEnabled()
{
    return (*properties)["StackTraceEnabled"].getBoolean() ;
}

void WireFormatInfo::setStackTraceEnabled(bool stackTraceEnabled)
{
    (*properties)["StackTraceEnabled"] = MapItemHolder(stackTraceEnabled) ;
}

        
bool WireFormatInfo::getTcpNoDelayEnabled()
{
    return (*properties)["TcpNoDelayedEnabled"].getBoolean() ;
}

void WireFormatInfo::setTcpNoDelayEnabled(bool tcpNoDelayEnabled)
{
    (*properties)["TcpNoDelayedEnabled"] = MapItemHolder(tcpNoDelayEnabled) ;
}


bool WireFormatInfo::getSizePrefixDisabled()
{
    return (*properties)["SizePrefixDisabled"].getBoolean() ;
}

void WireFormatInfo::setSizePrefixDisabled(bool sizePrefixDisabled)
{
    (*properties)["SizePrefixDisabled"] = MapItemHolder(sizePrefixDisabled) ;
}

        
bool WireFormatInfo::getTightEncodingEnabled()
{
    return (*properties)["TightEncodingEnabled"].getBoolean() ;
}

void WireFormatInfo::setTightEncodingEnabled(bool tightEncodingEnabled)
{
    (*properties)["TightEncodingEnabled"] = MapItemHolder(tightEncodingEnabled) ;
}

int WireFormatInfo::marshal(p<IMarshaller> marshaller, int mode, p<IOutputStream> writer) throw (IOException)
{
    int size = 0 ;

    // BUG: Should write array size
    //size += marshaller->marshalByteArray(magic, mode, writer) ; 
    size += (int)magic.size() ;
    
    if( mode == IMarshaller::MARSHAL_WRITE )
        writer->write(magic.c_array(), 0, size) ;

    size += marshaller->marshalInt(version, mode, writer) ; 
    size += marshaller->marshalBoolean( properties != NULL, mode, writer) ;

    if( mode == IMarshaller::MARSHAL_SIZE )
    {
        //propsByteSize = sizeof(int) ;
        propsByteSize += marshaller->marshalMap(properties, mode, writer) ;
        size += propsByteSize ;
    }
    else
    {
        size += marshaller->marshalInt(propsByteSize, mode, writer) ; 
        size += marshaller->marshalMap(properties, mode, writer) ; 
    }
    return size ;
}

void WireFormatInfo::unmarshal(p<IMarshaller> marshaller, int mode, p<IInputStream> reader) throw (IOException)
{
    bool isNonNullProps ;

    // BUG: Should read array size
    //magic = marshaller->unmarshalByteArray(mode, reader) ; 
    reader->read(magic.c_array(), 0, 8) ;
    version = marshaller->unmarshalInt(mode, reader) ; 
    isNonNullProps = marshaller->unmarshalBoolean(mode, reader) ;
    if( isNonNullProps )
    {
        propsByteSize = marshaller->unmarshalInt(mode, reader) ;
        properties = marshaller->unmarshalMap(mode, reader) ; 
    }
    else
        properties = NULL ;
}
