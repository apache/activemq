/*
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at
  
  http://www.apache.org/licenses/LICENSE-2.0
  
  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
*/

#include "command/Message.h"

using namespace ActiveMQ::Command;

/*
 *
 *  Marshalling code for Open Wire Format for Message
 *
 *
 *  NOTE!: This file is autogenerated - do not modify!
 *         if you need to make a change, please see the Groovy scripts in the
 *         activemq-core module
 *
 */
bool
Message::isMarshalAware() const
{
    return true;
}

Message::Message()
{
    groupID_ = "";
    groupSequence_ = 0;
    correlationId_ = "";
    persistent_ = 0;
    expiration_ = 0;
    priority_ = 0;
    timestamp_ = 0;
    type_ = "";
    compressed_ = 0;
    redeliveryCounter_ = 0;
    arrival_ = 0;
    userID_ = "";
    recievedByDFBridge_ = 0;
}

int
Message::getCommandType() const
{
    return TYPE;
}

Message::~Message()
{
}

boost::shared_ptr<const ProducerId> Message::getProducerId() const
{
    return producerId_;
}

void Message::setProducerId(const boost::shared_ptr<ProducerId>& producerId)
{
    producerId_ = producerId;
}

boost::shared_ptr<const ActiveMQDestination> Message::getDestination() const
{
    return destination_;
}

void Message::setDestination(const boost::shared_ptr<ActiveMQDestination>& destination)
{
    destination_ = destination;
}

boost::shared_ptr<const TransactionId> Message::getTransactionId() const
{
    return transactionId_;
}

void Message::setTransactionId(const boost::shared_ptr<TransactionId>& transactionId)
{
    transactionId_ = transactionId;
}

boost::shared_ptr<const ActiveMQDestination> Message::getOriginalDestination() const
{
    return originalDestination_;
}

void Message::setOriginalDestination(const boost::shared_ptr<ActiveMQDestination>& originalDestination)
{
    originalDestination_ = originalDestination;
}

boost::shared_ptr<const MessageId> Message::getMessageId() const
{
    return messageId_;
}

void Message::setMessageId(const boost::shared_ptr<MessageId>& messageId)
{
    messageId_ = messageId;
}

boost::shared_ptr<const TransactionId> Message::getOriginalTransactionId() const
{
    return originalTransactionId_;
}

void Message::setOriginalTransactionId(const boost::shared_ptr<TransactionId>& originalTransactionId)
{
    originalTransactionId_ = originalTransactionId;
}

const std::string& Message::getGroupID() const
{
    return groupID_;
}

void Message::setGroupID(const std::string& groupID)
{
    groupID_ = groupID;
}

int Message::getGroupSequence() const
{
    return groupSequence_;
}

void Message::setGroupSequence(int groupSequence)
{
    groupSequence_ = groupSequence;
}

const std::string& Message::getCorrelationId() const
{
    return correlationId_;
}

void Message::setCorrelationId(const std::string& correlationId)
{
    correlationId_ = correlationId;
}

bool Message::isPersistent() const
{
    return persistent_;
}

void Message::setPersistent(bool persistent)
{
    persistent_ = persistent;
}

int64_t Message::getExpiration() const
{
    return expiration_;
}

void Message::setExpiration(int64_t expiration)
{
    expiration_ = expiration;
}

uint8_t Message::getPriority() const
{
    return priority_;
}

void Message::setPriority(uint8_t priority)
{
    priority_ = priority;
}

boost::shared_ptr<const ActiveMQDestination> Message::getReplyTo() const
{
    return replyTo_;
}

void Message::setReplyTo(const boost::shared_ptr<ActiveMQDestination>& replyTo)
{
    replyTo_ = replyTo;
}

int64_t Message::getTimestamp() const
{
    return timestamp_;
}

void Message::setTimestamp(int64_t timestamp)
{
    timestamp_ = timestamp;
}

const std::string& Message::getType() const
{
    return type_;
}

void Message::setType(const std::string& type)
{
    type_ = type;
}

const std::vector<unsigned char>& Message::getContent() const
{
    return content_;
}

void Message::setContent(const std::vector<uint8_t>& content)
{
    content_ = content;
}

const std::vector<unsigned char>& Message::getMarshalledProperties() const
{
    return marshalledProperties_;
}

void Message::setMarshalledProperties(const std::vector<uint8_t>& marshalledProperties)
{
    marshalledProperties_ = marshalledProperties;
}

const boost::shared_ptr<const IDataStructure>& Message::getDataStructure() const
{
    return dataStructure_;
}

void Message::setDataStructure(const boost::shared_ptr<IDataStructure>& dataStructure)
{
    dataStructure_ = dataStructure;
}

boost::shared_ptr<const ConsumerId> Message::getTargetConsumerId() const
{
    return targetConsumerId_;
}

void Message::setTargetConsumerId(const boost::shared_ptr<ConsumerId>& targetConsumerId)
{
    targetConsumerId_ = targetConsumerId;
}

bool Message::isCompressed() const
{
    return compressed_;
}

void Message::setCompressed(bool compressed)
{
    compressed_ = compressed;
}

int Message::getRedeliveryCounter() const
{
    return redeliveryCounter_;
}

void Message::setRedeliveryCounter(int redeliveryCounter)
{
    redeliveryCounter_ = redeliveryCounter;
}

const std::vector<boost::shared_ptr<const BrokerId> >& Message::getBrokerPath() const
{
    return brokerPath_;
}

void Message::setBrokerPath(const std::vector<boost::shared_ptr<const BrokerId> >& brokerPath)
{
    brokerPath_ = brokerPath;
}

int64_t Message::getArrival() const
{
    return arrival_;
}

void Message::setArrival(int64_t arrival)
{
    arrival_ = arrival;
}

const std::string& Message::getUserID() const
{
    return userID_;
}

void Message::setUserID(const std::string& userID)
{
    userID_ = userID;
}

bool Message::isRecievedByDFBridge() const
{
    return recievedByDFBridge_;
}

void Message::setRecievedByDFBridge(bool recievedByDFBridge)
{
    recievedByDFBridge_ = recievedByDFBridge;
}
